/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   add_rm_tetri.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <fjanoty@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/02/03 22:11:42 by fjanoty           #+#    #+#             */
/*   Updated: 2016/02/12 11:20:27 by fjanoty          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "add_rm_tetri.h"
#include "debug.h"
#include <stdio.h>

/*area[x][y]*/
unsigned	long	ft_working_window(t_sqare *gr, int x, int y)
{
	unsigned	long	mh;
	unsigned	long	mv;
	unsigned	long	ecr;

	mh = get_vertical_mask(x);
	mv = get_horizontal_mask(y);
	ecr = ((gr->area[0][0] & ~mv & ~mh) >> (x + (8 * y)));
	ecr |= (((gr->area[0][1] & mv & ~mh) >> x) << (8 * (8 - y)));
	ecr |= (((gr->area[1][0] & ~mv & mh) << (8 - x)) >> (8 * y));
	ecr |= ((gr->area[1][1] & mv & mh) << ((8 - x) + (8 * (8 - y))));
	return (ecr);
}

void	ft_init_windows(unsigned long *windows, int stage)
{
	int					i;
	t_sqare				*ground;
	int					nb_win;
	int					x;
	int					y;

	ground = glb_ground(GET, 0);
	nb_win = glb_nb_windows(GET, 0);
	i = 0;
	y = stage * 4;
	while (i < nb_win)
	{
		x = (i * 4);
		windows[i] = ft_working_window(ground, x, y);
		i++;
	}
}

int		ft_set_tetris(unsigned long valu, int x, int y)
{
	unsigned	long	mh;
	unsigned	long	mv;
	t_sqare				*gr;

	gr = glb_ground(GET, 0);
	x *= 4;
	y *= 4;
	mv = get_vertical_mask(8 - x);
	mh = get_horizontal_mask(8 - y);
	gr->area[0][0] ^= (valu & mv & mh) << (x + (8 * y));
	gr->area[0][1] ^= ((valu & mv & ~mh) << x) >> (8 * (8 - y ));
	gr->area[1][0] ^= ((valu & ~mv & mh) >> (8 - x)) << (8 * y);
	gr->area[1][1] ^= (valu & ~mv & ~mh) >> (8 - x + (8 * (8 - y)));
	return (1);
}

void	ft_remouve_tetris(t_tetriminos *tetri)
{
	ft_set_tetris(tetri->valu, tetri->xs, tetri->ys);
	ft_resting_posx(tetri);
	ft_resting_posy(tetri);
	tetri->xs = 0;
	tetri->ys = 0;
}

int		ft_last_loop(t_tetriminos *elem, int dim, unsigned long *windows)
{
	while ((X < 8 - DIM_X) && X + (4 * ECR_X) < dim - DIM_X)
	{
		if ((elem->valu & windows[ECR_X]) == 0)
		{
			ft_set_tetris(elem->valu, ECR_X, ECR_Y);
			return (1);
		}
		elem->valu <<= 1;
		(X)++;
	}
	(ECR_X)++;
	ft_resting_posx(elem);
	return (0);
}

//void	ft_reset

int	ft_push_tetriminos(t_tetriminos *elem)
{
	unsigned	long	windows[3];
	int					nb_windows;
	int					dim;
	
	nb_windows = glb_nb_windows(GET, 0);
	dim = glb_sqr_dim(GET, 0);
	ECR_X = 0;
	while (ECR_Y < nb_windows)
	{
		ft_init_windows(windows, ECR_Y);
		while ((Y < 8 - DIM_Y) && Y + (4 * ECR_Y) < dim - DIM_Y)
		{
			while(ECR_X < nb_windows)
			{
				if (ft_last_loop(elem, dim, windows))
					return (1);
			}
			ECR_X = 0;
			elem->valu <<= 8;
			(Y)++;
		}
		(ECR_Y)++;
	}
	ft_resting_posy(elem);
	ft_resting_posx(elem);
	ECR_Y = 0;
	ECR_X = 0;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   create_coordone.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <fjanoty@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/01/05 18:23:53 by fjanoty           #+#    #+#             */
/*   Updated: 2016/02/12 05:20:52 by fjanoty          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "coordone.h"

t_coordone		*create_coordone(void)
{
	t_coordone	*position;

	if (!(position = (t_coordone*)malloc(sizeof(t_coordone))))
		return (NULL);
	position->x = 0;
	position->y = 0;
	return (position);
}

t_coordone		*create_coordone_y(int y)
{
	t_coordone	*position;

	if (!(position = (t_coordone*)malloc(sizeof(t_coordone))))
		return (NULL);
	position->x = 0;
	position->y = y;
	return (position);
}

void			copy_coordone(t_coordone *pos_dst, t_tetriminos *tetris)
{
	pos_dst->x = tetris->xp + (tetris->xp * 4);
	pos_dst->y = tetris->yp + (tetris->yp * 4);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   debug.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <fjanoty@student.fr>               +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/01/27 06:46:52 by fjanoty           #+#    #+#             */
/*   Updated: 2016/02/12 06:05:31 by fjanoty          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "debug.h"

void	print_long(unsigned long valu)
{
	int					i;
	int					j;
	unsigned	long	unite;
	
	i = 0;
	j = 0;
	unite = 1;
	while (j < 8)
	{
		while (i < 8)
		{
			if (valu & unite << (i + (8 * j)))
				printf("#");
			else
				printf(".");
			i++;
		}
		printf("\n");
		j++;
	}
}

void	print_working_windows(unsigned long *windows)
{
	int	nb_windows;
	int	j;

	j = 0;
	nb_windows = glb_nb_windows(GET, 0);
	while (j < nb_windows)
	{
		dprintf(1, "windows:%d", j);
		print_long(windows[j]);
		j++;
	}
	dprintf(1, "\n");
}

void	print_ground(t_sqare *sqr)
{
	int	i;
	int	j;
	unsigned long unite;

	j = 0;
	unite = 1;
	dprintf(1, "len_sqr:%d\n", sqr->dim);
	while (j < 16)
	{
		i = 0;
		while (i < 16)
		{
			if (i == 8)
				dprintf(1, " | ");
			if (sqr->area[i / 8][j / 8] & (unite << ((i % 8) + (8 * (j % 8)))))
				dprintf(1, "#");
			else
				dprintf(1, ".");
			i++;
		}
		dprintf(1, "\n");
		j++;
		if (j == 8)
			dprintf(1, "--------   --------\n");
	}
}

void	print_tetris(t_tetriminos *piece)
{
	int					i;
	int					j;
	unsigned	long	unite;

	dprintf(1, "\n");
	unite = 1;
	j = 0;
	while (j < 8)
	{
		i = 0;
		while (i < 8)
		{
			if (piece->valu & (unite << (j * 8 + i)))
				dprintf(1, "#");
			else
				dprintf(1, ".");
			i++;
		}
		dprintf(1, "\n");
		j++;
	}
}

void	print_coordone(int x, int y, char *name)
{
	dprintf(1, "%s: x:%d ", name, x);
	dprintf(1, "%s: y:%d\n", name, y);
}

void	describe_tetris(t_tetriminos *tetris)
{
	print_tetris(tetris);
	dprintf(1, "valu :%ld   ", (long)tetris->valu);
	dprintf(1, "id   :%c   ", tetris->id);
	dprintf(1, "type :%d   ", tetris->type);
	dprintf(1, "gap  :%d\n", tetris->gap);
	print_coordone(tetris->xd, tetris->yd, " dim");
	print_coordone(tetris->xp, tetris->yp, " pos");
	print_coordone(tetris->xs, tetris->ys, " ecr");
}

void	print_all_tetris(t_tetriminos *tetris)
{
	if (tetris->id >= 'A' && tetris->id <= 'Y')
	{
		describe_tetris(tetris);
		print_all_tetris(tetris++);
	}
	if (tetris->id == 'Z')
		describe_tetris(tetris);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <fjanoty@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/01/05 18:23:53 by fjanoty           #+#    #+#             */
/*   Updated: 2016/02/05 03:51:54 by fjanoty          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

void			ft_exit(int mode)
{
	if (mode)
		ft_putstr_fd("error\n", 1);
	exit(0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   filling.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <fjanoty@student.fr>               +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/01/27 07:38:47 by fjanoty           #+#    #+#             */
/*   Updated: 2016/02/12 23:00:49 by tboos            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "filling.h"

void			actual_mini_maxi(t_tetriminos *tetris, int i)
{
	int	x;
	int	y;

	x = i % 5;
	y = i / 5;
	if (x < tetris->xp)
		tetris->xp = x;
	if (y < tetris->yp)
		tetris->yp = y;
	if (x > tetris->xd)
		tetris->xd = x;
	if (y > tetris->yd)
		tetris->yd = y;
}

int				first_case(char *str)
{
	int	i;

	i = 0;
	while (i < 14)
	{
		if (i % 5 == 4 && str[i] != '\n')
			return (-1);
		if (i % 5 != 4 && str[i] == '#')
			return (i);
		else if (i % 5 != 4 && str[i] != '.')
			return (-1);
		i++;
	}
	return (-1);
}

void			search_the_diese(char *piece, t_tetriminos *tetris,
				int *nb, int i)
{
	unsigned	long	unite;

	unite = 1;
	if (piece[i] == '#')
	{
		piece[i] = '.';
		tetris->valu += unite << (i % 5 + ((i / 5) * 8));
		*nb += 1;
		actual_mini_maxi(tetris, i);
		if ((i - 1) % 5 != 4 && (i - 1) >= 0)
			search_the_diese(piece, tetris, nb, i - 1);
		if ((i + 1) % 5 != 4 && (i + 1) < 20)
			search_the_diese(piece, tetris, nb, i + 1);
		if (i + 5 < 20)
			search_the_diese(piece, tetris, nb, i + 5);
	}
	else if (piece[i] != '.')
		tetris->id = 0;
}

int				style_alive(char *str)
{
	int	i;

	i = 0;
	while (i < 20)
	{
		if (str[i] == '#'
		|| (i % 5 == 4 && str[i] != '\n')
		|| (i % 5 != 4 && str[i] != '.'))
			return (1);
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fillit_structure.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <fjanoty@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/01/05 18:23:53 by fjanoty           #+#    #+#             */
/*   Updated: 2016/02/13 01:12:21 by tboos            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"
#include "structure.h"
#include "glb.h"

static int		my_free(void *addr)
{
	free(addr);
	return (1);
}

int				get_next_piece(char *tab, t_tetriminos *tetris, int id)
{
	int		dieses;

	create_tetriminos(tetris, id);
	dieses = 0;
	if ((tetris->gap = first_case(tab)) < 0)
		return (0);
	search_the_diese(tab, tetris, &dieses, tetris->gap);
	if (tetris->id == 0 || dieses != 4 || style_alive(tab))
		return (0);
	finished_tetriminos(tetris);
	return (1);
}

t_tetriminos	*get_the_pieces(char *tab, int nb, int ret, t_tetriminos *array)
{
	int				i;

	i = 20;
	while (i < ret && tab[i] == '\n')
		i += 21;
	if (i < ret || !(array = (t_tetriminos *)malloc(sizeof(t_tetriminos) * nb)))
		ft_exit(1);
	i = 0;
	nb = 0;
	while (i < ret)
	{
		if (!(get_next_piece(tab + i, &(array[nb]), nb)))
		{
			free(array);
			ft_exit(1);
		}
		tetris_define_type(array, nb);
		i += 21;
		nb++;
	}
	return (array);
}

void			fillit_structure(char *tab, int ret)
{
	t_tetriminos	*array;
	t_tetriminos	**arrow;
	int				nb;
int i;
	array = NULL;
	nb = (ret + 1) / 21;
dprintf(1, "nb = %d\n", nb);
	array = get_the_pieces(tab, nb, ret, array);
dprintf(1, "yop1\n");
	if (!(arrow = (t_tetriminos **)malloc(sizeof(t_tetriminos *) * nb)) 
		&& my_free(array))
		ft_exit(1);
i=0;
while (i < nb)
{
dprintf(1, "i = %d\ntetrid = %d\n", i, (array[i]).id);
i++;
}
	nb = 0;
	while (nb < (ret + 1) / 21)
	{
		arrow[nb] = &(array[nb]);
		nb++;
	}
i=0;
while (i < nb)
{
dprintf(1, "i = %d\ntetrid = %d\n", i, (arrow[i])->id);
i++;
}
dprintf(1, "yop1\n");
	glb_ground(SET, ft_create_square());
	arrow = ft_squ_lunch(arrow, nb - 1);
	ft_print_result(*arrow, nb);
	free(array);
	free(arrow);
	ft_exit(0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_reorder.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tboos <toussaint.boos@gmail.com>           +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/02/03 18:15:02 by tboos             #+#    #+#             */
/*   Updated: 2016/02/13 00:33:09 by tboos            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

t_tetriminos	**ft_reorder(t_tetriminos **arrow, int stage, int len)
{
	int				i;
	int				m;

	if ((stage - 1) >= 0)
		ft_remouve_tetris(arrow[stage - 1]);
	while (stage < len)
	{
		i = stage + 1;
		m = stage;
		while (i <= len)
		{
			if (arrow[i]->id < arrow[m]->id)
				m = i;
			i++;
		}
		if (m != stage)
			ft_tetriswap(arrow, stage, m);
		stage++;
	}
	return (NULL);
}

void		ft_tetriswap(t_tetriminos **arrow, int stage, int i)
{
	t_tetriminos	*s;

	s = arrow[stage];
	arrow[stage] = arrow[i];
	arrow[i] = s;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tetriorder.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tboos <marvin@42.fr>                       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/02/03 18:14:15 by tboos             #+#    #+#             */
/*   Updated: 2016/02/13 00:40:23 by tboos            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

# include "header.h"

static int	ft_followrightrabbit(t_tetriminos **arrow, int *i, int len, int *readymade)
{
	while (*i <= len && (*readymade & (arrow[*i])->type))
		(*i)++;
	if (*i <= len)
	{
		*readymade += (arrow[*i])->type;
		return (1);
	}
	return (0);
}

t_tetriminos			**ft_tetriorder(t_tetriminos **arrow, int len, int stage)
{
	int				i;
	int				readymade;
	t_tetriminos	**test;

	if (stage == len && ft_push_tetriminos(arrow[stage]))
		return (arrow);
	else if (stage == len)
		return (ft_reorder(arrow, stage, len));
	i = stage;
	readymade = 0;
	while (i <= len)
	{
		if (ft_push_tetriminos(arrow[stage]))
		{
			if ((test = ft_tetriorder(arrow, len, stage + 1)))
				return (test);
		}
		else
			return (ft_reorder(arrow, stage, len));
		if ((ft_followrightrabbit(arrow, &i, len, &readymade)))
			ft_tetriswap(arrow, stage, i);
	}
	return (ft_reorder(arrow, stage, len));
}

t_tetriminos			**ft_squ_lunch(t_tetriminos **arrow, int len)
{
	int				i;
	int				j;
	int				sq;

	i = (len + 1) * 4;
	j = 1;
	sq = 0;
	while (i > 0)
	{
		i = i - j;
		j += 2;
		sq++;
	}
	while (sq < 16)
	{
		glb_sqr_dim(SET, sq);
		if((arrow = ft_tetriorder(arrow, len - 1, 0)))
			return (arrow);
		sq++;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   glb.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <marvin@42.fr>                     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/02/03 21:51:14 by fjanoty           #+#    #+#             */
/*   Updated: 2016/02/13 00:19:20 by tboos            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "glb.h"

int		glb_nb_windows(int mode, int sqr_dim)
{
	static	int	nb_windows = 1;

	if (mode & GET)
		return (nb_windows);
	else if (mode & SET)
	{
		nb_windows = (sqr_dim <= 12) ? 2 : 3;
		nb_windows = (sqr_dim <= 8) ? 1 : nb_windows;
		return (nb_windows);
	}
	else
		return (1);
}

int		glb_sqr_dim(int mode, int value)
{
	static	int	sqr_dim = 1;
	t_sqare		*ground;

	if (mode & GET)
		return (sqr_dim);
	else if (mode & SET)
	{
		ground = glb_ground(GET, 0);
		ground->dim = value;
		glb_nb_windows(SET, value);
		sqr_dim = value;
		return (sqr_dim);
	}
	else
		return (1);
}

t_sqare	*glb_ground(int mode, t_sqare *value)
{
	static	t_sqare	*ground;

	if (mode & GET)
		return (ground);
	else if (mode & SET)
	{
		ground = value;
		glb_sqr_dim(SET, ground->dim);
		return (ground);
	}
	else
		return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <fjanoty@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/11/03 22:45:56 by fjanoty           #+#    #+#             */
/*   Updated: 2016/02/12 21:43:03 by tboos            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "header.h"

int		main(int ac, char **av)
{
	int		fd;
	int		ret;
	char	buf[BUF];

	if (ac == 2)
		if ((fd = open(av[1], O_RDONLY, S_IREAD)) > 0)
		{
			if ((ret = read(fd, buf, BUF)))
				if ((ret + 1) % 21 == 0)
				{
					buf[ret] = '\0';
					close(fd);
					fillit_structure(buf, ret);
				}
			close(fd);
			ft_putstr_fd("error\n", 1);
		}
	if (ac != 2)
		ft_putstr_fd("usage: fillit source_file\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   manip_bin.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <fjanoty@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/02/04 20:05:26 by fjanoty           #+#    #+#             */
/*   Updated: 2016/02/12 05:07:08 by fjanoty          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "manip_bin.h"

unsigned	long	get_vertical_mask(int size)
{
	static	unsigned	long	masks[9];
	static	int					init = 1;
	unsigned	long			vertical;
	int							i;
	int							j;

	if (init)
	{
		init = 0;
		vertical = VERTICAL;
		j = 0;
		while (j < 9)
		{
			i = 0;
			masks[j] = 0;
			while (i < j)
			{
				masks[j] |= vertical << i;
				i++;
			}
			j++;
		} 
	}
	return (masks[size]);
}

unsigned	long	get_horizontal_mask(int size)
{
	static	unsigned	long	masks[9];
	static	int					init = 1;
	unsigned	long			horizontal;
	int							i;
	int							j;

	if (init)
	{
		init = 0;
		horizontal = HORIZONTAL;
		j = 0;
		while (j < 9)
		{
			i = 0;
			masks[j] = 0;
			while (i < j)
			{
				masks[j] |= horizontal << (i * 8);
				i++;
			}
			j++;
		} 
	}
	return (masks[size]);
}

void		ft_resting_posx(t_tetriminos *elem)
{
	elem->valu >>= (elem->xp);
	elem->xp = 0;
}

void		ft_resting_posy(t_tetriminos *elem)
{
	elem->valu >>= ((elem->yp) * 8);
	elem->yp = 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <fjanoty@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/02/03 22:03:34 by fjanoty           #+#    #+#             */
/*   Updated: 2016/02/13 03:45:47 by tboos            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "print.h"
#include <stdio.h>
#include "header.h"
#include "debug.h"

char	*ft_init_str_result(int len)
{
	char	*result;
	int		i;

	i = 0;
	if (!(result = (char*)malloc(sizeof(char) * (len * (len + 1) + 1))))
		return (NULL);
	while (i < len * (len + 1))
	{
		if (i % (len + 1) == len)
			result[i] = '\n';
		else
			result[i] = '.';
		i++;
	}
	result[i] = '\0';
	return (result);
}

void	ft_add_strtetri(t_tetriminos *elem, t_coordone *pos, char *str, int len)
{
	int	i;
	int	j;

	j = 0;
	while (j < 4)
	{
		i = 0;
		while (i < 4)
		{
			if (elem->valu & (1 << (i + (8 * j))))
				str[i + pos->x + ((len + 1) * (j + pos->y))] = elem->id;
			i++;
		}
		j++;
	}
}

void	ft_print_result(t_tetriminos *begin, int size)
{
	t_coordone	*pos;
	int			len;
	char		*result;
	int			i;

	i = 0;
	pos = create_coordone();
	len = glb_sqr_dim(GET, 0) - 1;
	result = ft_init_str_result(len);
	while (i < size)
	{
		copy_coordone(pos, begin);
		ft_resting_posx(begin);
		ft_resting_posy(begin);
		ft_add_strtetri(begin, pos, result, len);
		begin += sizeof(t_tetriminos);
		i++;
	}
	ft_putstr(result);
	free(result);
	free(pos);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   square_result.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <fjanoty@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/01/05 18:23:53 by fjanoty           #+#    #+#             */
/*   Updated: 2016/02/05 06:18:56 by fjanoty          ###   ########.fr       */
/*                                                                            */
/*                                                                            */
/* ************************************************************************** */

# include "square_result.h"

t_sqare	*ft_create_square(void)
{
	t_sqare	*ground;
	int		i;
	int		j;

	ground = (t_sqare*)malloc(sizeof(t_sqare));
	if (!ground)
		return (NULL);
	ground->area = (unsigned long **)malloc(sizeof(unsigned long *) * 2);
	if (!ground->area)
		return (NULL);
	i = 0;
	while (i < 2)
	{
		j = -1;
		ground->area[i] = (unsigned long *)malloc(sizeof(unsigned long) * 2);
		if (!ground->area[i])
			return (NULL);
		while (++j < 2)
			ground->area[i][j] = 0;
		i++;
	}
	ground->dim = 0;
	return (ground);
}






//ft_tetrilen(t_tetriminos);


/*	IMPRIMER LES PIECE:
 *		-on sauvgard la position
 *		-on decale la piece en haut a gauche
 *		-on fait une boucle sur un carer de 4*4
 *			-on incremente a la bose position chaque piece;
 *
 * */


/*
   .
00 | 10
<- # ->
01 | 11
   .
*/

/*
 *	mask_v = get_vertical_mask(scr_pos->x * 4);
 *
 *
*/



/*	ENLEVER UNE PIECE
 *
 *	c'est comme si on veux l'ajouter
 *	sauf que on veux ecrire des 0 au lieu d'ecrire des 1
 *
 *
 *
 * */

/*
AJOIUTER UNE PIECE
	-Il faut stoquer le tableau dans un singleton mais garder 
	l'adresse en memoir.
nb ecr:
	1 si dim <= 8
	2 si dim <= 12
	3 si dim <= 16
-on check sur la largeur
	-on peu switcher d'ecran
	-et revenir a la ligne (recalage de la piece)
-qund on a fini la hauteur des ecran on en regenere 3 autre
	-on reclae la piece tut comme il faut
	et on recomence
quand on a tout fini et que c'est nun on renvoir (0)

j < nb_ecr
{
	y < 8 - dim->y
	{
		i < nb_ecr
		{
			x < 8 - dim->x
			{
				x++
			}
			raz->x(ecr) && i++
		}
		y++
	}
	get_window();
	raz->y(ecr) && j++
}

(i,j) -> indice
(x,y) -> pos

CONVERSION (x(ecr) + i) => x(ground)
	- ground->x - (4 * indice->x) = ecr->x
	- ecr->x + (4 * indice->x) = ground->x
CONVERSION (y(ecr) + j) => y(ground)
	- ground->y - (4 * indice->y) = ecr->y
	- ecr->y + (4 * indice->y) = ground->y

+++++++++++++++++++++++++++++++
ou commencer sur un nouvelle ecran

	-on les renouvelle quand on a fini
largeur de travaille = 8 - largeur de la piece
01234567 89ABCDEF
........ ........
........ ........
........ ........
........ ........
........ ........
........ ........
........ ........
........ ........

12 = 2*6 
12 = 3*4
12 = 4*3
12 = 1*12

26*4




AAAABBBBCCCC
DDDDEEEEFFFF
GGGGHHHHIIII
JJJJKKKKLLLL
MMMMNNNNOOOO
PPPPQQQQRRRR
SSSSTTTTUUUU
VVVVWWWWXXXX
YYYYZZZZ....
............
............
............


01234567 | 456789ABCD


*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tetriminos.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fjanoty <fjanoty@student.fr>               +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2016/01/27 06:06:49 by fjanoty           #+#    #+#             */
/*   Updated: 2016/02/12 23:00:56 by tboos            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "tetriminos.h"
#include <stdio.h>

void				create_tetriminos(t_tetriminos *piece, int id)
{
	piece->id = id + 'A';
	piece->valu = 0;
	piece->xp = 8;
	piece->yp = 8;
	piece->xd = 0;
	piece->yd = 0;
	piece->xs = 0;
	piece->ys = 0;
}

void				tetris_define_type(t_tetriminos *array, int nb)
{
	int				type_max;
	t_tetriminos	*tetris;
	int				first;

	type_max = 1;
	tetris = &(array[nb]);
	first = 1;
	nb--;
	while (nb >= 0)
	{
		first = 0;
		if ((array[nb]).type > type_max)
			type_max = (array[nb]).type;
		if ((array[nb]).valu == tetris->valu)
			break;
		nb--;
	}
	if (nb)
		tetris->type = (array[nb]).type;
	else if (first)
		tetris->type = type_max;
	else
		tetris->type = type_max << 1;
}

void			finished_tetriminos(t_tetriminos *tetris)
{
	tetris->gap = (tetris->gap % 5) - tetris->xp; 
	tetris->xd = tetris->xd - tetris->xp;
	tetris->yd = tetris->yd - tetris->yp;
	tetris->valu = tetris->valu >> (tetris->xp + (tetris->yp * 8));
	tetris->xp = 0;
	tetris->yp = 0;
}
